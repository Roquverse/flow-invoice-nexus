import { useState, useEffect } from "react";
import { supabase } from "@/integrations/supabase/client";
import { Receipt } from "@/types/receipts";
import { toast } from "sonner";
import { useClients } from "./useClients";
import { useInvoices } from "./useInvoices";

// Memoized receipt number for the current session
let cachedReceiptNumber: string | null = null;

export const useReceipts = () => {
  const [receipts, setReceipts] = useState<Receipt[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const { clients } = useClients();
  const { invoices } = useInvoices();

  useEffect(() => {
    const fetchReceipts = async () => {
      setLoading(true);
      try {
        const { data, error } = await supabase
          .from("receipts")
          .select("*")
          .order("created_at", { ascending: false });

        if (error) {
          throw error;
        }

        // Ensure data conforms to Receipt type
        const typedReceipts =
          (data?.map((item) => ({
            ...item,
            // Ensure payment_method is one of the allowed values
            payment_method: validatePaymentMethod(item.payment_method),
          })) as Receipt[]) || [];

        setReceipts(typedReceipts);
      } catch (error) {
        setError((error as Error).message || "Failed to fetch receipts");
      } finally {
        setLoading(false);
      }
    };

    fetchReceipts();
  }, []);

  // Helper function to validate payment method
  const validatePaymentMethod = (
    method: string
  ): "cash" | "bank_transfer" | "credit_card" | "paypal" | "other" => {
    const validMethods = [
      "cash",
      "bank_transfer",
      "credit_card",
      "paypal",
      "other",
    ];
    return validMethods.includes(method)
      ? (method as
          | "cash"
          | "bank_transfer"
          | "credit_card"
          | "paypal"
          | "other")
      : "other";
  };

  // Generate a receipt number
  const generateReceiptNumber = async (): Promise<string> => {
    // Return cached receipt number if available
    if (cachedReceiptNumber) {
      return cachedReceiptNumber;
    }

    try {
      // Get the current date
      const date = new Date();
      const year = date.getFullYear().toString().slice(-2);
      const month = (date.getMonth() + 1).toString().padStart(2, "0");
      const day = date.getDate().toString().padStart(2, "0");

      // Use timestamp for uniqueness
      const timestamp = Date.now().toString().slice(-6);

      // Create receipt number in format RCT-YYMMDD-XXXXXX (last 6 digits of timestamp)
      const receiptNumber = `RCT-${year}${month}${day}-${timestamp}`;

      // Cache the receipt number for this session
      cachedReceiptNumber = receiptNumber;

      return receiptNumber;
    } catch (error) {
      console.error("Error generating receipt number:", error);
      // Fallback to simpler timestamp
      const fallback = `RCT-${Date.now()}`;
      cachedReceiptNumber = fallback;
      return fallback;
    }
  };

  const createReceipt = async (receiptData: Receipt) => {
    setLoading(true);
    try {
      // Get the current user
      const { data: userData, error: userError } =
        await supabase.auth.getUser();

      if (userError || !userData.user) {
        throw new Error("User authentication required");
      }

      // First, let's log the exact data we're receiving
      console.log(
        "Original receipt data:",
        JSON.stringify(receiptData, null, 2)
      );

      // Create a sanitized version with null for empty UUIDs
      const sanitizedData = {
        ...receiptData,
        // Add user_id from the authenticated user - required for RLS
        user_id: userData.user.id,
        // Remove quote_id and invoice_id from the object completely if empty strings
        ...(receiptData.quote_id === "" || receiptData.quote_id === undefined
          ? { quote_id: null }
          : {}),
        ...(receiptData.invoice_id === "" ||
        receiptData.invoice_id === undefined
          ? { invoice_id: null }
          : {}),
        // Handle other nullable fields
        reference: receiptData.reference || null,
        payment_reference: receiptData.payment_reference || null,
        notes: receiptData.notes || null,
      };

      // Remove empty UUID fields completely from the object for insertion
      const dataToInsert = { ...sanitizedData };

      // CRITICAL: Remove the id field - it should be generated by Supabase
      delete dataToInsert.id;

      // If quote_id is empty or null, delete it from the object
      if (!dataToInsert.quote_id) {
        delete dataToInsert.quote_id;
      }

      // If invoice_id is empty or null, delete it from the object
      if (!dataToInsert.invoice_id) {
        delete dataToInsert.invoice_id;
      }

      console.log(
        "Sanitized receipt data for insert:",
        JSON.stringify(dataToInsert, null, 2)
      );

      const { data, error } = await supabase
        .from("receipts")
        .insert([dataToInsert])
        .select();

      if (error) {
        console.error("Supabase error creating receipt:", error);
        throw error;
      }

      // Transform and type the data
      const newReceipts = data?.map((item) => ({
        ...item,
        payment_method: validatePaymentMethod(item.payment_method),
      })) as Receipt[];

      setReceipts((prevReceipts) => [...prevReceipts, ...newReceipts]);
      toast.success("Receipt created successfully!");
    } catch (error) {
      const errorMessage =
        error instanceof Error
          ? error.message
          : typeof error === "object" && error !== null && "message" in error
          ? String(error.message)
          : "Failed to create receipt";

      console.error("Receipt creation error:", error);
      setError(errorMessage);
      toast.error(errorMessage);
    } finally {
      setLoading(false);
    }
  };

  const updateReceipt = async (id: string, updates: Partial<Receipt>) => {
    setLoading(true);
    try {
      // Get the current user
      const { data: userData, error: userError } =
        await supabase.auth.getUser();

      if (userError || !userData.user) {
        throw new Error("User authentication required");
      }

      console.log("Original update data:", JSON.stringify(updates, null, 2));

      // Create sanitized data
      const sanitizedData = {
        ...updates,
        // We don't need to include user_id on updates since we filter by id
        // Handle quote_id and invoice_id
        ...(updates.quote_id === "" || updates.quote_id === undefined
          ? { quote_id: null }
          : {}),
        ...(updates.invoice_id === "" || updates.invoice_id === undefined
          ? { invoice_id: null }
          : {}),
        // Handle other fields
        reference: updates.reference || null,
        payment_reference: updates.payment_reference || null,
        notes: updates.notes || null,
      };

      // Remove empty UUID fields completely from the object for update
      const dataToUpdate = { ...sanitizedData };

      // CRITICAL: Remove the id field - we don't update the primary key
      delete dataToUpdate.id;

      // If quote_id is empty, delete it from the object
      if (!dataToUpdate.quote_id) {
        delete dataToUpdate.quote_id;
      }

      // If invoice_id is empty, delete it from the object
      if (!dataToUpdate.invoice_id) {
        delete dataToUpdate.invoice_id;
      }

      console.log(
        "Sanitized update data:",
        JSON.stringify(dataToUpdate, null, 2)
      );

      const { data, error } = await supabase
        .from("receipts")
        .update(dataToUpdate)
        .eq("id", id)
        .select();

      if (error) {
        console.error(`Error updating receipt ${id}:`, error);
        throw error;
      }

      // Ensure updated data conforms to Receipt type
      const updatedReceipt =
        data && data[0]
          ? ({
              ...data[0],
              payment_method: validatePaymentMethod(data[0].payment_method),
            } as Receipt)
          : null;

      if (updatedReceipt) {
        setReceipts((prevReceipts) =>
          prevReceipts.map((receipt) =>
            receipt.id === id ? updatedReceipt : receipt
          )
        );
      }
      toast.success("Receipt updated successfully!");
    } catch (error) {
      const errorMessage =
        error instanceof Error
          ? error.message
          : typeof error === "object" && error !== null && "message" in error
          ? String(error.message)
          : "Failed to update receipt";

      setError(errorMessage);
      toast.error(errorMessage);
    } finally {
      setLoading(false);
    }
  };

  const deleteReceipt = async (id: string) => {
    try {
      setLoading(true);
      const { error } = await supabase.from("receipts").delete().eq("id", id);

      if (error) throw error;

      // Update state by removing the deleted receipt
      setReceipts((prev) => prev.filter((receipt) => receipt.id !== id));

      toast.success("Receipt deleted successfully!");
    } catch (error) {
      const errorMessage =
        error instanceof Error
          ? error.message
          : typeof error === "object" && error !== null && "message" in error
          ? String(error.message)
          : "Failed to delete receipt";

      setError(errorMessage);
      toast.error(errorMessage);
    } finally {
      setLoading(false);
    }
  };

  // Function to get client name
  const getClientName = (clientId: string) => {
    const client = clients.find((client) => client.id === clientId);
    return client ? client.business_name : "Unknown Client";
  };

  // Function to get invoice number
  const getInvoiceNumber = (invoiceId: string) => {
    const invoice = invoices.find((invoice) => invoice.id === invoiceId);
    return invoice ? invoice.invoice_number : "Unknown Invoice";
  };

  // Function to delete a receipt (alias for deleteReceipt)
  const removeReceipt = (id: string) => {
    return deleteReceipt(id);
  };

  return {
    receipts,
    loading,
    error,
    createReceipt,
    updateReceipt,
    deleteReceipt,
    removeReceipt,
    generateReceiptNumber,
    getClientName,
    getInvoiceNumber,
  };
};
